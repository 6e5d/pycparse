[
[S
	[+ blocks]
]
[blocks
	[!]
	[blocks blocks block]
]
[block
	[+ Defun]
	[+ Typedef]
]
[Typedef
	[typedef "typedef" Declare ";"]
	[typedef_nc "typedef" "var" "type" ";"]
	[typedef_ncs "typedef" "sue" "var" "type" ";"]
]
[Defun
	[defun Declare Procedure]
]
[Dparams
	[! "void"]
	[dparams. Declare]
	[dparams Dparams "," Declare]
]
[Declare
	[declare Ptype Dbody]
	[declare_static "static" Ptype Dbody]
]
[Stmtdec
	[declare Ptype StmtdecBodys]
]
[StmtdecBodys
	[stmtdec_bodys. StmtdecBody]
	[stmtdec_bodys StmtdecBodys "," StmtdecBody]
]
[StmtdecBody
	[+ Dbody]
	[decinit Dbody "=" Initval]
]

# primitive type
[Ptype
	[sue "sue" "type"]
	[. "type"]
	[. "void"]
]

[Type
	[type Ptype Tbody]
]
[Tbody
	[+ Tbody2]
	[ptr "*" Tbody]
]
[Tbody2
	[!]
	[+ Tbody3]
	[fun Tbody3 "(" Dparams ")"]
	[array Tbody2 "[" Lit "]"]
]
[Tbody3
	[paren "(" Tbody ")"]
]

[Dbody
	[+ Dbody2]
	[ptr "*" Dbody]
]
[Dbody2
	[+ Dbody3]
	[fun Dbody2 "(" Dparams ")"]
	[array Dbody2 "[" Lit "]"]
]
[Dbody3
	[. "var"]
	[paren "(" Dbody ")"]
]
[Procedure
	[begin "{" Stmts "}"]
]
[Stmts
	[!]
	[stmts Stmts Stmt]
]
[Stmt
	[+ Stmt2 ";"]
	[+ If]
	[return "return" Expr ";"]
	[returnvoid "return" ";"]
	[continue "continue" ";"]
	[break "break" ";"]
	[while "while" "(" Expr ")" Procedure]
	[for "for" "(" Stmt2 ";" Stmt2 ";" Stmt2 ")" Procedure]
]
[If
	[if "if" "(" Expr ")" Procedure Ifcont]
]
[Ifcont
	[!]
	[elif "else" If]
	[else "else" Procedure]
]
# Stmt that can appear in for
[Stmt2
	[!]
	[+ Expr]
	[+ Stmtdec]
]
[Initval
	[+ Expr]
	[initval "{" Sinits "}"]
	[initval "{" Sinits "," "}"]
]
[Sinits
	[sinits. Sinit]
	[sinits Sinits "," Sinit]
]
[Sinit
	[+ Initval]
	[sinit "member" "var" "=" Initval]
]
[Expr
	[+ Expr14]
]
[Expr14
	[+ Expr12]
	[assign Expr14 "opassign" Expr12]
	[assign Expr14 "=" Expr12]
]
[Expr12
	[+ Expr11]
	[binop Expr12 "||" Expr11]
]
[Expr11
	[+ Expr7]
	[binop Expr11 "&&" Expr7]
]
[Expr7
	[+ Expr6]
	[binop Expr7 "eqneq" Expr6]
]
[Expr6
	[+ Expr4]
	[binop Expr6 "relation" Expr4]
]
[Expr4
	[+ Expr3]
	[binop Expr4 "add" Expr3]
]
[Expr3
	[+ Expr2]
	[binop Expr3 "divmod" Expr2]
	[binop Expr3 "*" Expr2]
]
[Expr2
	[+ Expr1]
	[deref "*" Expr1]
	[addr "prefix" Expr1]
	[cast "(" Type ")" Expr1]
]
[Expr1
	[+ Lit]
	[paren "(" Expr ")"]
	[index Expr1 "[" Expr "]"]
	[callvoid Expr1 "(" ")"]
	[call Expr1 "(" params ")"]
	[sizeof "sizeof" "(" Type ")"]
	[member Expr1 "member" "var"]
]
[params
	[params. Expr]
	[params params "," Expr]
]
[Lit
	[+ Clit]
	[. "var"]
]
[Clit
	[. "num"]
	[strlit Strcat]
	[char "char"]
]
[Strcat
	[strcat. "str"]
	[strcat Strcat "str"]
]
]
